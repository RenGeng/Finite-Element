load "gmsh";
// mesh Th=gmshload("Data/sous-marin.msh");
mesh Th=gmshload("Data/easySurf.msh");
plot(Th, wait= true, cmm = "Mon superbe maillage");

// border a(t=0,2*pi){ x=cos(t); y=sin(t);label=3;}
// border b(t=0,2*pi){ x=0.3+0.3*cos(t); y=0.3*sin(t);label=2;}
// mesh Th= buildmesh(a(50)+b(-30));

plot(Th, wait= true, cmm = "Mon superbe maillage");
// savemesh(Th,"Th.msh");


fespace Vh(Th, P1);
Vh<complex> uh,vh;

complex L=1i;
real k = 2*pi;
real alpha = pi/2;
func uinc=exp(k*L*(x*cos(alpha) + y*sin(alpha)));

// ************* Matrix Resolution of the Problem *************  

// real cpu=clock();

// varf Helmholtz(uh,vh) = -int2d(Th)(dx(uh)*dx(vh)) -int2d(Th)(dy(uh)*dy(vh))
// + int2d(Th)(k*k*uh*vh) + on (3,uh=-uinc) - int1d(Th,2)(L*k*uh*vh);


// matrix<complex> A = Helmholtz( Vh, Vh);
// Vh<complex> B, solution;
// B[] = Helmholtz(0, Vh);
// solution[] = A^-1 * B[];
// cout<<"CPU time="<<clock()-cpu<<endl;

// { 
//   ofstream fout("Data/mat_B.txt") ;
//   fout << B[] << endl ;
// }  

// plot(solution, wait = true, cmm = "Solution", value = true, fill = true, dim = 2);

// { 
//   ofstream fout("Data/mat_FF.txt") ;
//   fout << A << endl ;
// }  

// ************* End of Matrix Resolution  ************* 

// couleur de plot
real[int] colorhsv=[ // color hsv model
    4./6., 1 , 0.5, // dark blue
    4./6., 1 , 1, // blue
    5./6., 1 , 1, // magenta
    1, 1. , 1, // red
    1, 0.5 , 1 // light red
    ];

real cpu=clock();
solve HelmholtzS(uh,vh) = -int2d(Th)(dx(uh)*dx(vh)) -int2d(Th)(dy(uh)*dy(vh)) 
+ int2d(Th)(k*k*(uh)*(vh)) + on (3,uh=-uinc) - int1d(Th,2)(L*k*uh*vh);
cout<<"CPU time="<<clock()-cpu<<endl;

{ 
  ofstream fout2("Data/mat_U.txt") ;
  fout2 << uh[] << endl ;
} 

Vh<complex> uabs = abs(uh + uinc);
Vh<complex> ure = real(uh);
Vh<complex> uim = imag(uh);

plot(uh,wait = true, cmm = "Solution complet", value = true, fill = true, dim = 2, hsv=colorhsv);
plot(ure,wait = true, cmm = "Solution relle", value = true, fill = true, dim = 2, hsv=colorhsv);
plot(uim,wait = true, cmm = "Solution imaginaire", value = true, fill = true, dim = 2, hsv=colorhsv);

// Pour obtenir les parties r√©elles, valeur absolue :

include "gmshExport.idp";
gmshExport(Th, uh[], "Data/uh.pos");
gmshExport(Th, ure[], "Data/ure.pos");
gmshExport(Th, uim[], "Data/uim.pos");
gmshExport(Th, uabs[], "Data/uabs.pos");